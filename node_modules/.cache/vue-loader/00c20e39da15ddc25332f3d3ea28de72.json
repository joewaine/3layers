{"remainingRequest":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/josephwaine/2020-top-3-app-modernization-landing-page/src/components/AnimationCanvas.vue?vue&type=style&index=0&id=5b129408&scoped=true&lang=scss&","dependencies":[{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/src/components/AnimationCanvas.vue","mtime":1581104794650},{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/css-loader/index.js","mtime":1581104905640},{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1581104906100},{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/postcss-loader/src/index.js","mtime":1581104906047},{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/sass-loader/lib/loader.js","mtime":1581104912452},{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/cache-loader/dist/cjs.js","mtime":1581104905589},{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/vue-loader/lib/index.js","mtime":1581104906100}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#animationContainer,\n#domOverlayContainer,\ncanvas {\n  width: 287px;\n  height: 360px;\n}\n\n#animationContainer {\n  /*background-color: rgba(2, 76, 110, 1.00);*/\n}\n\n#domOverlayContainer {\n  pointer-events: none;\n  overflow: hidden;\n  position: absolute;\n  left: 0;\n  top: 0;\n  display: block;\n}\n\ncanvas {\n  position: absolute;\n  display: block;\n  background-color: transparent;\n}\n",{"version":3,"sources":["AnimationCanvas.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2MA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"AnimationCanvas.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div id=\"animationContainer\" ref=\"animationContainer\">\n    <canvas ref=\"canvas\" id=\"canvas\" width=\"287\" height=\"360\"></canvas>\n    <div id=\"domOverlayContainer\" ref=\"domOverlayContainer\"></div>\n  </div>\n</template>\n\n<script>\n  /* eslint-disable no-undef,new-parens,new-cap */\n  import createjs from 'latest-createjs'\n  import * as animation from '@/assets/js/sdwan_security_animation.js'\n  import { TweenMax, Power4, Back, Power1 } from 'gsap/all'\n\n  let plugins = [Power4, Back, Power1, animation]\n  let stage\n  let exportRoot\n  let fnStartAnimation\n  let canvas\n  let animContainer\n  let domOverlayContainer\n  let lib\n  let comp\n\n  export default {\n    mounted () {\n      this.$nextTick(() => {\n        /* eslint-disable no-eval,camelcase,new-cap,no-undef,new-parens */\n        canvas = this.$refs.canvas\n        animContainer = this.$refs.animationContainer\n        domOverlayContainer = this.$refs.domOverlayContainer\n        comp = AdobeAn2.getComposition('6DEC752EC97C4A7B9A6B4C1B61DD3C28')\n        lib = comp.getLibrary()\n        this.handleComplete({}, comp)\n      })\n    },\n    methods: {\n      handleComplete (evt, comp) {\n        // This function is always called, irrespective of the content. You can use the letiable \"stage\" after it is created in token create_stage.\n        let lib = comp.getLibrary()\n        let ss = comp.getSpriteSheet()\n        exportRoot = new lib.initialize()\n        stage = new lib.Stage(canvas)\n        // Registers the \"tick\" event listener.\n        fnStartAnimation = function () {\n          stage.addChild(exportRoot)\n          createjs.Ticker.framerate = lib.properties.fps\n          createjs.Ticker.addEventListener('tick', stage)\n          stage.addEventListener('tick', handleTick)\n\n          function getProjectionMatrix (container, totalDepth) {\n            let focalLength = 528.25\n            let projectionCenter = {\n              x: lib.properties.width / 2, y: lib.properties.height / 2\n            }\n            let scale = (totalDepth + focalLength) / focalLength\n            let scaleMat = new createjs.Matrix2D\n            scaleMat.a = 1 / scale\n            scaleMat.d = 1 / scale\n            let projMat = new createjs.Matrix2D\n            projMat.tx = -projectionCenter.x\n            projMat.ty = -projectionCenter.y\n            projMat = projMat.prependMatrix(scaleMat)\n            projMat.tx += projectionCenter.x\n            projMat.ty += projectionCenter.y\n            return projMat\n          }\n\n          function handleTick () {\n            let cameraInstance = exportRoot.___camera___instance\n            if (cameraInstance !== undefined && cameraInstance.pinToObject !== undefined) {\n              cameraInstance.x = cameraInstance.pinToObject.x + cameraInstance.pinToObject.pinOffsetX\n              cameraInstance.y = cameraInstance.pinToObject.y + cameraInstance.pinToObject.pinOffsetY\n              if (cameraInstance.pinToObject.parent !== undefined && cameraInstance.pinToObject.parent.depth !== undefined) {\n                cameraInstance.depth = cameraInstance.pinToObject.parent.depth + cameraInstance.pinToObject.pinOffsetZ\n              }\n            }\n            applyLayerZDepth(exportRoot)\n          }\n\n          function applyLayerZDepth (parent) {\n            let cameraInstance = parent.___camera___instance\n            let focalLength = 528.25\n            let projectionCenter = {\n              'x': 0,\n              'y': 0\n            }\n            if (parent === exportRoot) {\n              let stageCenter = {\n                'x': lib.properties.width / 2,\n                'y': lib.properties.height / 2\n              }\n              projectionCenter.x = stageCenter.x\n              projectionCenter.y = stageCenter.y\n            }\n            for (let child in parent.children) {\n              let layerObj = parent.children[child]\n              if (layerObj === cameraInstance) {\n                continue\n              }\n              applyLayerZDepth(layerObj, cameraInstance)\n              if (layerObj.layerDepth === undefined) {\n                continue\n              }\n              if (layerObj.currentFrame !== layerObj.parent.currentFrame) {\n                layerObj.gotoAndPlay(layerObj.parent.currentFrame)\n              }\n              let matToApply = new createjs.Matrix2D\n              let cameraMat = new createjs.Matrix2D\n              let totalDepth = layerObj.layerDepth ? layerObj.layerDepth : 0\n              let cameraDepth = 0\n              if (cameraInstance && !layerObj.isAttachedToCamera) {\n                let mat = cameraInstance.getMatrix()\n                mat.tx -= projectionCenter.x\n                mat.ty -= projectionCenter.y\n                cameraMat = mat.invert()\n                cameraMat.prependTransform(projectionCenter.x, projectionCenter.y, 1, 1, 0, 0, 0, 0, 0)\n                cameraMat.appendTransform(-projectionCenter.x, -projectionCenter.y, 1, 1, 0, 0, 0, 0, 0)\n                if (cameraInstance.depth) {\n                  cameraDepth = cameraInstance.depth\n                }\n              }\n              if (layerObj.depth) {\n                totalDepth = layerObj.depth\n              }\n              // Offset by camera depth\n              totalDepth -= cameraDepth\n              if (totalDepth < -focalLength) {\n                matToApply.a = 0\n                matToApply.d = 0\n              } else {\n                if (layerObj.layerDepth) {\n                  let sizeLockedMat = getProjectionMatrix(parent, layerObj.layerDepth)\n                  if (sizeLockedMat) {\n                    sizeLockedMat.invert()\n                    matToApply.prependMatrix(sizeLockedMat)\n                  }\n                }\n                matToApply.prependMatrix(cameraMat)\n                let projMat = getProjectionMatrix(parent, totalDepth)\n                if (projMat) {\n                  matToApply.prependMatrix(projMat)\n                }\n              }\n              layerObj.transformMatrix = matToApply\n            }\n          }\n        }\n\n        // Code to support hidpi screens and responsive scaling.\n        function makeResponsive (isResp, respDim, isScale, scaleType) {\n          let lastW\n          let lastH\n          let lastS = 1\n          window.addEventListener('resize', resizeCanvas)\n          resizeCanvas()\n\n          function resizeCanvas () {\n            let w = lib.properties.width\n            let h = lib.properties.height\n            let iw = window.innerWidth\n            let ih = window.innerHeight\n            let pRatio = window.devicePixelRatio || 1\n            let xRatio = iw / w\n            let yRatio = ih / h\n            let sRatio = 1\n            if (isResp) {\n              if ((respDim === 'width' && lastW === iw) || (respDim === 'height' && lastH === ih)) {\n                sRatio = lastS\n              } else if (!isScale) {\n                if (iw < w || ih < h) {\n                  sRatio = Math.min(xRatio, yRatio)\n                }\n              } else if (scaleType === 1) {\n                sRatio = Math.min(xRatio, yRatio)\n              } else if (scaleType === 2) {\n                sRatio = Math.max(xRatio, yRatio)\n              }\n            }\n            canvas.width = w * pRatio * sRatio\n            canvas.height = h * pRatio * sRatio\n            canvas.style.width = domOverlayContainer.style.width = animContainer.style.width = w * sRatio + 'px'\n            canvas.style.height = animContainer.style.height = domOverlayContainer.style.height = h * sRatio + 'px'\n            stage.scaleX = pRatio * sRatio\n            stage.scaleY = pRatio * sRatio\n            lastW = iw\n            lastH = ih\n            lastS = sRatio\n            stage.tickOnUpdate = false\n            stage.update()\n            stage.tickOnUpdate = true\n            // stage.setClearColor('rgba(0,0,0,0)')\n          }\n        }\n\n        makeResponsive(false, 'both', false, 1)\n        AdobeAn2.compositionLoaded(lib.properties.id)\n        fnStartAnimation()\n      }\n    }\n  }\n</script>\n\n<style scoped lang=\"scss\">\n  #animationContainer,\n  #domOverlayContainer,\n  canvas {\n    width: 287px;\n    height: 360px;\n  }\n\n  #animationContainer {\n    /*background-color: rgba(2, 76, 110, 1.00);*/\n  }\n\n  #domOverlayContainer {\n    pointer-events: none;\n    overflow: hidden;\n    position: absolute;\n    left: 0;\n    top: 0;\n    display: block;\n  }\n\n  canvas {\n    position: absolute;\n    display: block;\n    background-color: transparent;\n  }\n</style>\n"]}]}