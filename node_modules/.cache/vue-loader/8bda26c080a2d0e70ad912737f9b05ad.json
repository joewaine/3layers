{"remainingRequest":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/josephwaine/2020-top-3-app-modernization-landing-page/src/components/HeroCanvas.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/src/components/HeroCanvas.vue","mtime":1581104794650},{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/cache-loader/dist/cjs.js","mtime":1581104905589},{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/babel-loader/lib/index.js","mtime":1581104901680},{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/cache-loader/dist/cjs.js","mtime":1581104905589},{"path":"/Users/josephwaine/2020-top-3-app-modernization-landing-page/node_modules/vue-loader/lib/index.js","mtime":1581104906100}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n\n/* eslint-disable no-undef,new-parens,new-cap */\nimport createjs from 'latest-createjs'\nimport * as header from '@/assets/js/sdwan_security_header.js'\nimport { TweenMax, Power4, Back, Power1 } from 'gsap/all'\n\nlet plugins = [Power4, Back, Power1, header]\nlet stage\nlet exportRoot\nlet fnStartAnimation\nlet canvas\nlet animContainer\nlet domOverlayContainer\nlet lib\nlet comp\n\nexport default {\n  props: {\n    width: {\n      type: Number\n    },\n    height: {\n      type: Number\n    }\n  },\n  mounted () {\n    this.$nextTick(() => {\n      /* eslint-disable no-eval,camelcase,new-cap,no-undef,new-parens */\n      canvas = this.$refs.canvas\n      animContainer = this.$refs.animationContainer\n      domOverlayContainer = this.$refs.domOverlayContainer\n      comp = AdobeAn.getComposition('75E5B44073054A3BB18A39FF12D81F5E')\n      lib = comp.getLibrary()\n      this.handleComplete({}, comp)\n    })\n  },\n  methods: {\n    handleComplete (evt, comp) {\n      // This function is always called, irrespective of the content. You can use the letiable \"stage\" after it is created in token create_stage.\n      let lib = comp.getLibrary()\n      let ss = comp.getSpriteSheet()\n      exportRoot = new lib.initialize()\n      stage = new lib.Stage(canvas)\n      // Registers the \"tick\" event listener.\n      fnStartAnimation = function () {\n        stage.addChild(exportRoot)\n        createjs.Ticker.framerate = lib.properties.fps\n        createjs.Ticker.addEventListener('tick', stage)\n        stage.addEventListener('tick', handleTick)\n\n        function getProjectionMatrix (container, totalDepth) {\n          let focalLength = 528.25\n          let projectionCenter = {\n            x: lib.properties.width / 2, y: lib.properties.height / 2\n          }\n          let scale = (totalDepth + focalLength) / focalLength\n          let scaleMat = new createjs.Matrix2D\n          scaleMat.a = 1 / scale\n          scaleMat.d = 1 / scale\n          let projMat = new createjs.Matrix2D\n          projMat.tx = -projectionCenter.x\n          projMat.ty = -projectionCenter.y\n          projMat = projMat.prependMatrix(scaleMat)\n          projMat.tx += projectionCenter.x\n          projMat.ty += projectionCenter.y\n          return projMat\n        }\n\n        function handleTick () {\n          let cameraInstance = exportRoot.___camera___instance\n          if (cameraInstance !== undefined && cameraInstance.pinToObject !== undefined) {\n            cameraInstance.x = cameraInstance.pinToObject.x + cameraInstance.pinToObject.pinOffsetX\n            cameraInstance.y = cameraInstance.pinToObject.y + cameraInstance.pinToObject.pinOffsetY\n            if (cameraInstance.pinToObject.parent !== undefined && cameraInstance.pinToObject.parent.depth !== undefined) {\n              cameraInstance.depth = cameraInstance.pinToObject.parent.depth + cameraInstance.pinToObject.pinOffsetZ\n            }\n          }\n          applyLayerZDepth(exportRoot)\n        }\n\n        function applyLayerZDepth (parent) {\n          let cameraInstance = parent.___camera___instance\n          let focalLength = 528.25\n          let projectionCenter = {\n            'x': 0,\n            'y': 0\n          }\n          if (parent === exportRoot) {\n            let stageCenter = {\n              'x': lib.properties.width / 2,\n              'y': lib.properties.height / 2\n            }\n            projectionCenter.x = stageCenter.x\n            projectionCenter.y = stageCenter.y\n          }\n          for (let child in parent.children) {\n            let layerObj = parent.children[child]\n            if (layerObj === cameraInstance) {\n              continue\n            }\n            applyLayerZDepth(layerObj, cameraInstance)\n            if (layerObj.layerDepth === undefined) {\n              continue\n            }\n            if (layerObj.currentFrame !== layerObj.parent.currentFrame) {\n              layerObj.gotoAndPlay(layerObj.parent.currentFrame)\n            }\n            let matToApply = new createjs.Matrix2D\n            let cameraMat = new createjs.Matrix2D\n            let totalDepth = layerObj.layerDepth ? layerObj.layerDepth : 0\n            let cameraDepth = 0\n            if (cameraInstance && !layerObj.isAttachedToCamera) {\n              let mat = cameraInstance.getMatrix()\n              mat.tx -= projectionCenter.x\n              mat.ty -= projectionCenter.y\n              cameraMat = mat.invert()\n              cameraMat.prependTransform(projectionCenter.x, projectionCenter.y, 1, 1, 0, 0, 0, 0, 0)\n              cameraMat.appendTransform(-projectionCenter.x, -projectionCenter.y, 1, 1, 0, 0, 0, 0, 0)\n              if (cameraInstance.depth) {\n                cameraDepth = cameraInstance.depth\n              }\n            }\n            if (layerObj.depth) {\n              totalDepth = layerObj.depth\n            }\n            // Offset by camera depth\n            totalDepth -= cameraDepth\n            if (totalDepth < -focalLength) {\n              matToApply.a = 0\n              matToApply.d = 0\n            } else {\n              if (layerObj.layerDepth) {\n                let sizeLockedMat = getProjectionMatrix(parent, layerObj.layerDepth)\n                if (sizeLockedMat) {\n                  sizeLockedMat.invert()\n                  matToApply.prependMatrix(sizeLockedMat)\n                }\n              }\n              matToApply.prependMatrix(cameraMat)\n              let projMat = getProjectionMatrix(parent, totalDepth)\n              if (projMat) {\n                matToApply.prependMatrix(projMat)\n              }\n            }\n            layerObj.transformMatrix = matToApply\n          }\n        }\n      }\n\n      // Code to support hidpi screens and responsive scaling.\n      function makeResponsive (isResp, respDim, isScale, scaleType) {\n        let lastW\n        let lastH\n        let lastS = 1\n        window.addEventListener('resize', resizeCanvas)\n        resizeCanvas()\n\n        function resizeCanvas () {\n          let w = lib.properties.width\n          let h = lib.properties.height\n          let iw = window.innerWidth\n          let ih = window.innerHeight\n          let pRatio = window.devicePixelRatio || 1\n          let xRatio = iw / w\n          let yRatio = ih / h\n          let sRatio = 1\n          if (isResp) {\n            if ((respDim === 'width' && lastW === iw) || (respDim === 'height' && lastH === ih)) {\n              sRatio = lastS\n            } else if (!isScale) {\n              if (iw < w || ih < h) {\n                sRatio = Math.min(xRatio, yRatio)\n              }\n            } else if (scaleType === 1) {\n              sRatio = Math.min(xRatio, yRatio)\n            } else if (scaleType === 2) {\n              sRatio = Math.max(xRatio, yRatio)\n            }\n          }\n          canvas.width = w * pRatio * sRatio\n          canvas.height = h * pRatio * sRatio\n          canvas.style.width = domOverlayContainer.style.width = animContainer.style.width = w * sRatio + 'px'\n          canvas.style.height = animContainer.style.height = domOverlayContainer.style.height = h * sRatio + 'px'\n          stage.scaleX = pRatio * sRatio\n          stage.scaleY = pRatio * sRatio\n          lastW = iw\n          lastH = ih\n          lastS = sRatio\n          stage.tickOnUpdate = false\n          stage.update()\n          stage.tickOnUpdate = true\n        }\n      }\n\n      makeResponsive(false, 'both', false, 1)\n      AdobeAn.compositionLoaded(lib.properties.id)\n      fnStartAnimation()\n    }\n  }\n}\n",{"version":3,"sources":["HeroCanvas.vue"],"names":[],"mappings":";;;;;;;;AAQA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"HeroCanvas.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div id=\"animationContainer\" ref=\"animationContainer\">\n    <canvas ref=\"canvas\" id=\"canvas\" :width=\"width\" :height=\"height\"></canvas>\n    <div id=\"domOverlayContainer\" ref=\"domOverlayContainer\"></div>\n  </div>\n</template>\n\n<script>\n  /* eslint-disable no-undef,new-parens,new-cap */\n  import createjs from 'latest-createjs'\n  import * as header from '@/assets/js/sdwan_security_header.js'\n  import { TweenMax, Power4, Back, Power1 } from 'gsap/all'\n\n  let plugins = [Power4, Back, Power1, header]\n  let stage\n  let exportRoot\n  let fnStartAnimation\n  let canvas\n  let animContainer\n  let domOverlayContainer\n  let lib\n  let comp\n\n  export default {\n    props: {\n      width: {\n        type: Number\n      },\n      height: {\n        type: Number\n      }\n    },\n    mounted () {\n      this.$nextTick(() => {\n        /* eslint-disable no-eval,camelcase,new-cap,no-undef,new-parens */\n        canvas = this.$refs.canvas\n        animContainer = this.$refs.animationContainer\n        domOverlayContainer = this.$refs.domOverlayContainer\n        comp = AdobeAn.getComposition('75E5B44073054A3BB18A39FF12D81F5E')\n        lib = comp.getLibrary()\n        this.handleComplete({}, comp)\n      })\n    },\n    methods: {\n      handleComplete (evt, comp) {\n        // This function is always called, irrespective of the content. You can use the letiable \"stage\" after it is created in token create_stage.\n        let lib = comp.getLibrary()\n        let ss = comp.getSpriteSheet()\n        exportRoot = new lib.initialize()\n        stage = new lib.Stage(canvas)\n        // Registers the \"tick\" event listener.\n        fnStartAnimation = function () {\n          stage.addChild(exportRoot)\n          createjs.Ticker.framerate = lib.properties.fps\n          createjs.Ticker.addEventListener('tick', stage)\n          stage.addEventListener('tick', handleTick)\n\n          function getProjectionMatrix (container, totalDepth) {\n            let focalLength = 528.25\n            let projectionCenter = {\n              x: lib.properties.width / 2, y: lib.properties.height / 2\n            }\n            let scale = (totalDepth + focalLength) / focalLength\n            let scaleMat = new createjs.Matrix2D\n            scaleMat.a = 1 / scale\n            scaleMat.d = 1 / scale\n            let projMat = new createjs.Matrix2D\n            projMat.tx = -projectionCenter.x\n            projMat.ty = -projectionCenter.y\n            projMat = projMat.prependMatrix(scaleMat)\n            projMat.tx += projectionCenter.x\n            projMat.ty += projectionCenter.y\n            return projMat\n          }\n\n          function handleTick () {\n            let cameraInstance = exportRoot.___camera___instance\n            if (cameraInstance !== undefined && cameraInstance.pinToObject !== undefined) {\n              cameraInstance.x = cameraInstance.pinToObject.x + cameraInstance.pinToObject.pinOffsetX\n              cameraInstance.y = cameraInstance.pinToObject.y + cameraInstance.pinToObject.pinOffsetY\n              if (cameraInstance.pinToObject.parent !== undefined && cameraInstance.pinToObject.parent.depth !== undefined) {\n                cameraInstance.depth = cameraInstance.pinToObject.parent.depth + cameraInstance.pinToObject.pinOffsetZ\n              }\n            }\n            applyLayerZDepth(exportRoot)\n          }\n\n          function applyLayerZDepth (parent) {\n            let cameraInstance = parent.___camera___instance\n            let focalLength = 528.25\n            let projectionCenter = {\n              'x': 0,\n              'y': 0\n            }\n            if (parent === exportRoot) {\n              let stageCenter = {\n                'x': lib.properties.width / 2,\n                'y': lib.properties.height / 2\n              }\n              projectionCenter.x = stageCenter.x\n              projectionCenter.y = stageCenter.y\n            }\n            for (let child in parent.children) {\n              let layerObj = parent.children[child]\n              if (layerObj === cameraInstance) {\n                continue\n              }\n              applyLayerZDepth(layerObj, cameraInstance)\n              if (layerObj.layerDepth === undefined) {\n                continue\n              }\n              if (layerObj.currentFrame !== layerObj.parent.currentFrame) {\n                layerObj.gotoAndPlay(layerObj.parent.currentFrame)\n              }\n              let matToApply = new createjs.Matrix2D\n              let cameraMat = new createjs.Matrix2D\n              let totalDepth = layerObj.layerDepth ? layerObj.layerDepth : 0\n              let cameraDepth = 0\n              if (cameraInstance && !layerObj.isAttachedToCamera) {\n                let mat = cameraInstance.getMatrix()\n                mat.tx -= projectionCenter.x\n                mat.ty -= projectionCenter.y\n                cameraMat = mat.invert()\n                cameraMat.prependTransform(projectionCenter.x, projectionCenter.y, 1, 1, 0, 0, 0, 0, 0)\n                cameraMat.appendTransform(-projectionCenter.x, -projectionCenter.y, 1, 1, 0, 0, 0, 0, 0)\n                if (cameraInstance.depth) {\n                  cameraDepth = cameraInstance.depth\n                }\n              }\n              if (layerObj.depth) {\n                totalDepth = layerObj.depth\n              }\n              // Offset by camera depth\n              totalDepth -= cameraDepth\n              if (totalDepth < -focalLength) {\n                matToApply.a = 0\n                matToApply.d = 0\n              } else {\n                if (layerObj.layerDepth) {\n                  let sizeLockedMat = getProjectionMatrix(parent, layerObj.layerDepth)\n                  if (sizeLockedMat) {\n                    sizeLockedMat.invert()\n                    matToApply.prependMatrix(sizeLockedMat)\n                  }\n                }\n                matToApply.prependMatrix(cameraMat)\n                let projMat = getProjectionMatrix(parent, totalDepth)\n                if (projMat) {\n                  matToApply.prependMatrix(projMat)\n                }\n              }\n              layerObj.transformMatrix = matToApply\n            }\n          }\n        }\n\n        // Code to support hidpi screens and responsive scaling.\n        function makeResponsive (isResp, respDim, isScale, scaleType) {\n          let lastW\n          let lastH\n          let lastS = 1\n          window.addEventListener('resize', resizeCanvas)\n          resizeCanvas()\n\n          function resizeCanvas () {\n            let w = lib.properties.width\n            let h = lib.properties.height\n            let iw = window.innerWidth\n            let ih = window.innerHeight\n            let pRatio = window.devicePixelRatio || 1\n            let xRatio = iw / w\n            let yRatio = ih / h\n            let sRatio = 1\n            if (isResp) {\n              if ((respDim === 'width' && lastW === iw) || (respDim === 'height' && lastH === ih)) {\n                sRatio = lastS\n              } else if (!isScale) {\n                if (iw < w || ih < h) {\n                  sRatio = Math.min(xRatio, yRatio)\n                }\n              } else if (scaleType === 1) {\n                sRatio = Math.min(xRatio, yRatio)\n              } else if (scaleType === 2) {\n                sRatio = Math.max(xRatio, yRatio)\n              }\n            }\n            canvas.width = w * pRatio * sRatio\n            canvas.height = h * pRatio * sRatio\n            canvas.style.width = domOverlayContainer.style.width = animContainer.style.width = w * sRatio + 'px'\n            canvas.style.height = animContainer.style.height = domOverlayContainer.style.height = h * sRatio + 'px'\n            stage.scaleX = pRatio * sRatio\n            stage.scaleY = pRatio * sRatio\n            lastW = iw\n            lastH = ih\n            lastS = sRatio\n            stage.tickOnUpdate = false\n            stage.update()\n            stage.tickOnUpdate = true\n          }\n        }\n\n        makeResponsive(false, 'both', false, 1)\n        AdobeAn.compositionLoaded(lib.properties.id)\n        fnStartAnimation()\n      }\n    }\n  }\n</script>\n\n<style scoped lang=\"scss\">\n  #canvas {\n    @media (max-width: 1275px) {\n      display: none;\n    }\n  }\n\n  #animationContainer,\n  #domOverlayContainer,\n  canvas {\n    width: 1300px;\n    height: 598px\n  }\n\n  #animationContainer {\n    /*background-color: rgba(2, 76, 110, 1.00);*/\n  }\n\n  #domOverlayContainer {\n    pointer-events: none;\n    overflow: hidden;\n    position: absolute;\n    left: 0;\n    top: 0;\n    display: block;\n  }\n\n  canvas {\n    position: absolute;\n    display: block;\n    background-color: transparent;\n  }\n</style>\n"]}]}